# Overview

This document explains the method to interlock Analytics SDK on Android. In order to utilize Analytics SDK, one should register for an app. To register, refer to the link (<http://docs.cloud.toast.com/ko/Analytics/App%20Analytics/Getting%20Started/#_4>).

**Contents about campaign implementation are provided in a separate document. In this document, implementation of client is only explained. As for overall contents, refer to “Campaign Implementation Guide**


# Project Setting


## SDK download

1. Analytics SDK download
 Download Android SDK file at <http://docs.cloud.toast.com/ko/Download/>
2. Google Service API download
 To use Advertising ID, Google Player Service is needed in Analytics SDK. Using Android SDK Manager, download the latest version of Google Player Service.
    (<https://developer.android.com/sdk/installing/adding-packages.html>)

## Project Setting

### Setting Library Dependency (Eclipse)
Copy the downloaded file to unzip GameAnalyticsSDK_Android_v1.xxx.zip into libs directory. (One of GameAnalytics SDK jar file, exist native library for collecting index of security/performance)

In case of the downloaded Google Service API, you should import the corresponding library into Eclipse in order to use it because it is not the jar type, but Android library.
(<http://developer.android.com/google/play-services/setup.html>)

After importing Google Service API into Eclipse, bring your cursor to the user project root folder that you are currently writing and right-click on it. 

In a pop-up window shown in response to right-clicking, click on Properties menu, and as described in the picture above, when a pop-up window comes up, choose Android in the left side of a pop-up, and then click on [Add] button on the right side around Library in order to set a route of Google Service API library.

### Setting Library Dependency (Android Studio)
Decompress the downloaded 'GameAnalyticsSDK_Android_v1.xxx.zip' file and an Android project named 'ToastAnalyticsSDK' will be created. Add the project as module and set dependency.

Add project in Android Studio and select 'File - New - Import Module.'

![Import Module Step1](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_003.png)

Select decompressed ToastAnalyticsSDK Android project path. 

![Import Module Step2](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_004.png)

Check options and proceed to the next step. A default value is generally used. 

![Import Module Step3](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_005.png)

Add module and set dependency. Select 'Project Structure' in 'File' menu first.

![Project Setting 1](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_006.png)

As you have added ToastAnalyticsSDK as a module, select module dependency.

![Project Setting 2](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_007.png)

Select toastAnalyticsSDK and add dependency.

![Project Setting 3](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_008.png)

You also need to add dependency for Google Play service library. If Google Play service is already added to the project, you may skip this step. 

![Project Setting 4](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_009.png)

The version of Google Play service may differ according to environment. Google Play Services version 7.5 and after is required to apply Toast Analytics SDK.

![Project Setting 5](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics/master/docs/Developer/images/pg_aos_010.png)

### AndroidManifest setting
In Analytics SDK, use the following Permission.


```xml
<!-- use for Terminal Modem Status (ex. Network Operator’s Name) reference. -->
<uses-permission android:name="android.permission.READ_PHONE_STATE"/>
<uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/>
<uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/>
<uses-permission android:name="android.permission.INTERNET" />
```

Store information is for tracking the market information that the user used for downloading the application. Available stores are as follows.
(If you use values other than the defined store, it will be categorized as 'etc.' If you need to add additional stores, please inquire upon the admin.)

Store | Input character string (android:value=)
------------- | -------------
Google Play Store | Google
Apple App Store | Apple
Naver Store | Naver
T-Store | Tstore
One Store | onestore
China AOS-360 | CN_360
China AOS-Baidu | CN_Baidu
China AOS-Xiaomi | CN_Xiaomi
China AOS-UC | CN_UC
China AOS-Bilibili | CN_Bilibili
China AOS-Flyme | CN_Flyme
China AOS-37 | CN_37
China AOS-Otaku | CN_Otaku
China AOS-OPPO | CN_Oppo
China AOS-HUAWEI | CN_Huawei
China AOS-ANZHI | CN_Anzhi
China AOS-WANDOU | CN_Wandou
China AOS-OtakuChannel | CN_OtakuChannel
China AOS-Tencent | CN_Tencent
China AOS-Lenovo | CN_Lenovo
China AOS-Site Directly distribute (*Not via market) | CN_Direct

```xml
<manifest>
    ……
    <application>
        ……
        <!—Store information setting -->
        <!-- android:value is Tstore, Olleh, Uplus, NaverApp etc  -->
        <meta-data
            android:name="com.toast.android.analytics.appstore"
            android:value="Google" />
        ……
    </application>
</manifest>
```
    

To analyze inflow route of installation, settings of Install Receiver is needed. (It only operates when an app is installed through Google Play.)

```xml
<manifest>
    ……
    <application>
        ……
        <receiver
            android:name="com.toast.android.analytics.InstallReferrerReceiver"
            android:exported="true">
            <intent-filter>
                <action android:name="com.android.vending.INSTALL_REFERRER"/>
            </intent-filter>
        </receiver>
        ……
    </application>
</manifest>
```

    
Only one within an app can be registered within Broadcast Receiver that processes the same Action. . In the event that Install Referrer is used at several places, it must be followed by guidelines below.

Add only one Receiver, and other Receivers through meta-data.

When Install Receiver is improperly set, a total of new users can be inaccurately estimated.

To add additional receivers, meta-data should be added like the settings below. At this point, write a corresponding Class name into Android:value.

```xml
<receiver 
    android:name="com.toast.android.analytics.InstallReferrerReceiver" 
    android:exported="true">
    <intent-filter>
        <action android:name="com.android.vending.INSTALL_REFERRER"/>
    </intent-filter>

    <meta-data android:name="forward1" android:value="Receiver-Class-Name" />
    <meta-data android:name="forward2" android:value=" Receiver-Class-Name" />
</receiver>
```
 
# Mandatory Implementation

It is API that should be implemented for the fundamental statistical data gathering. Most of data can be seen just by implementing the mandatory implementation.
Mandatory implementation items are the following.

* Initialization: initializeSDK
* Session-tracking : traceActivation, traceDeactivation
* Purchase (In App Purchase) : tracePurchase
* Money acquisition/consumption : traceMoneyAcquisition, traceMoneyConsumption
* Level-up : traceLevelUp
* Friend count : traceFriendCount


## Initialization

“App ID” and “Company ID” that are issued after registering for the app are necessarily needed to use SDK. As for the way to register for the app, refer to the link
(<http://cloud.toast.com/documents/2/>).

AppID of initializeSDK function use “AppKey” of app information, CompanayID use company id.

![App Key](https://raw.githubusercontent.com/ToastAnalytics/ToastAnalytics_EN/master/docs/Developer/images/pg_aos_002.png)

SDK initialization should be first carried out to utilize GameAnalytics SDK.

The InitializeSDK function of GameAnalytics class is a function that carries out SDK initialization. This function identifies internally needed information (device information, app setting information) and configures the environment for transporting log


```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, false);

    if(result != GameAnalytics.S_SUCCESS)
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));

    }

}
```
    
## User identification criteria setting

** Criteria should not be changed after opening the game because data link before and after a change can be disconnected during the operation.**

Analytics is a criterion that classifies users, using Advertise ID or User ID. Both ID cannot be used at the same time, but one of them should be chosen according to game policies.

Generally speaking, Advertise ID is used as a criterion. But, User ID is permitted in case of special requirements in the game.

For example, if a user drops out and re-registers on the same device under Advertise ID, the user is to be counted as the same previous user. On the other hand, in case of User ID, it is counted as a new user under the same condition.

Or, if one user uses two devices and utilizes Advertise ID, it is counted as two different users, whereas it is counted as just one user in case of User ID.

Considering features of the two different ID types, decide which criteria to use in the game.

This value can be set through the last factor (use logging userid flag) of initialization function (initializeSDK). In the event that Flag is true, use User ID as a criterion. If it is set as False, use Advertise ID as an identification criterion.

The code below is a case of using User ID as the user identification criterion.

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppID”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS)
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));

    }
    ……
    // Log-in completed in the game
    ……
    // a function for registering User ID in case of utilizing User ID as user identification criterion.
    GameAnalytics.setUserId(“user_id”, true);
    ……
}
```
    
If the last factor of initialization function (use logging userid flag) is set as true, User ID should be registered by calling setLoggingUserId. Unless Flag is set as true by calling setLoggingUserId, all API called afterwards will return a failure (E_LOGGING_USER_ID_EMPTY).

As for the second factor of setUserId, it is true in case of Promotion or Campaign. Otherwise, it is false.

SetUserId function can be called right after obtaining userID to use in the game after completion of log-in by calling initializeSDK.. UserID can be used as a value utilized to identify game users.


As for contents regarding Advertise ID, refer to the link below.
- Android : <https://developer.android.com/google/play-services/id.html>


## Session-tracking

It is an implementation to trace DAU (Daily Active User) and stay time in the game. 

It can be measured by calling a corresponding API in case of App start/end and Background/Foreground move. 

When App is first executed (after intializeSDK) or a move from background to foreground is made, start session-tracking by calling traceActivation. And then stop tracking by calling traceDeactivation at the moment of app’s moving into background. 

By calling traceDeactivation and measuring stay time between traceActivation and traceDeactivation, total hours of use can be estimated. Also, stop activities carried out internally within SDK at traceDeactivation. 

In case of Background/Foreground move, unless the function above hasn’t been called, hours of use in the game cannot be accurately estimated, so this API must be called. 

As for DAU, measure it through numbers extracted by getting rid of repetition of the user (Advertise ID or User ID as criteria) who called traceActivation for a day.

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onResume()
  {
    // notifying the server of a change to foreground status
    GameAnalytics.traceActivation(this);
  }

  @Override
  protected void onPause()
  {
    // notifying the server of a change to background status
    GameAnalytics.traceDeactivation(this);
  }
}
```


## Action-tracking

This can trace users’ Action on In-App Purchase, money acquisition/consumption, level-up, change in friend count, etc.

### In-App Purchase

This sends information about purchase by calling tracePurchase after In-App Purchase takes place. 

Currency is only used by code defined by ISO-4217(<http://en.wikipedia.org/wiki/ISO_4217>). 

In case of purchasing $0.99jewelry, it is used just as below. 

(“GEM_10” here is an item code defined in the game. Unit Cost means corresponding items’ unit price, and payment is the actual cost that users pay. Level is designated for the purchaser’s level.)

```java
GameAnalytics.tracePurchase("GEM_10", 0.99f, 0.99f, "USD", 10);
```


### Acquisition/Consumption of Goods

This calls when money is either acquired or consumed and traces the amount of change in primary and secondary goods. Generally speaking, primary goods (e.g. jewelry, ruby, etc.) are those purchased through In-App Purchase, while secondary goods (e.g. cherry, heart, etc.) are those purchase by utilizing the primary goods. 

In the event that 10 jewels are purchased through IAP, it is used just as below. 

(“CODE_IAP” here is a code defined in the game. In case of primary goods, the type is designated as 0, and 1 for secondary goods)

GameAnalytics.traceMoneyAcquisition("CODE_IAP", "0", 10, 10);

In case of purchasing 100 cherries, using 10 jewels, it is used just as described below.

```java
// Consumption of primary goods
GameAnalytics.traceMoneyConsumption("CODE_USE_GEM", "0", 10, 10);

// Acquisition of secondary goods
GameAnalytics.traceMoneyAcquisition("CODE_BUY_CHERRY", "1", 100, 10);
```

When secondary goods are purchased by using primary goods, actual move of ‘primary goods decrease’->’secondary goods increase’ takes place. But, if additional goods’ consumption is not necessarily required to be expressed, it is fine to send ‘secondary goods’ increase’ log.

### Level-up

It calls traceLevelUp when users’ levels are changed. For reference, most of Action-tracking API receives users’ levels in order to trace action for every level. 

If a user’s level changes to 10, it is called as below. A user’s level must go up. If it goes down, accurate data cannot be estimated. 

For instance, in a game that proceeds through stages like “Candy Crush Sage” in which stage is used as level, only when a user first proceeds into a new stage, corresponding stages should mark a log of level-up. If a user goes back and plays the previous stage, it should not mark a level-up log.

Also, level values that are sent to other API should use the highest stage level value as opposed to the currently ongoing stage.

```java
GameAnalytics.traceLevelUp(10);
```


### Friend

Register numbers of users’ friends. Generally, it is fine to call it at the moment when friend information loading is completed after executing the app.

```java
GameAnalytics.traceFriendCount(100);
```


# Optional Implementation

It explains additional indicators that users would want to utilize other than basic index provided by fundamental implementation, or the way to use a Campaign function offered by Analytics.

Items that can be additionally implemented are the following.

* Campaign implementation : setCampaignListener, (show/hide)Campaign
* Custom Event collection : traceEvent
* Duration measurement : traceStartSpeed, traceEndSpeed


## Campaign implementation

### Campaign implementation advance preparation
Separate guidelines are provided for Campaign implementation and its execution.
Refer to “Page guide” under “Campaign execution” in Toast Analytics.

### Push-implementation
You need to use Toast Cloud Push to use the push feature for campaigns in Analytics SDK.
Please refer to "Client SDK guide" that Toast Cloud Push offers for more information on 'Push.'

http://cloud.toast.com/documents/18/?content_id=145

Please refer to "Client SDK guide" that Toast Cloud Push offers for more information on 'Push.' 

You need to register 'custom receiver' provided by Toast Cloud Push SDK to AndroidManifest.xml file to use Push.

```xml 
<manifest>
  ……
  <application>
    ……
    <!-- When GCM is used  -->
    <service android:name="com.toast.android.analytics.receiver.GcmBroadcastReceiver" android:exported="false">
            <intent-filter>
                <action android:name="com.google.android.c2dm.intent.RECEIVE" />
            </intent-filter>
    </service>
    
    <!-- When Tencent is used -->
    <receiver android:name="com.toast.android.analytics.receiver.TencentBroadcastReceiver">
        <intent-filter>
            <action android:name="com.tencent.android.tpush.action.PUSH_MESSAGE" />
            <action android:name="com.tencent.android.tpush.action.FEEDBACK" />
        </intent-filter>
    </receiver>
    …… 
    </application>
</manifest>
```

When server receives push (GCM) message, Analytics SDK displays notification to the Notification Bar. App will be initiated upon touching this notification. If no setting is done, main activity of the app will be displayed.

To run activity other than the main one, you need to explicitly designate the activity using "setPushIntent" function. 

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }
    ……
    Intent intent = new Intent(getApplicationContext(), GCMActivity.class);
    GameAnalytics.setPushIntent(intent);
    ……
```

When setting the launch mode of the Activity in AndroidManifest.xml as singeTop, singleTask or singleInstance, use the existing activity instead of creating a new one.

To correctly receive the 'Intent' information with Push data, you need to override "onNewIntent" explicitly in the concerned activity. 
```java
public class TestActivity extends Activity {
    
  @Override
  protected void onNewIntent(Intent intent) {
    super.onNewIntent(intent);
    setIntent(intent);
  }
}
```

Next, set the user ID information which was set as the register function element offered by Toast Cloud SDK as the element for GameAnalytics.tracePushUserId function. This user ID may differ from the user ID set in GameAnalytics.setUserId and it must be the user ID used as the element for 'register' function. Please refer to "Client SDK Guide" offered by Toast Cloud Push for more information on register function.

http://docs.cloud.toast.com/ko/Notification/Push/Client%20SDK%20Guide/

```java
import com.toast.android.analytics.GameAnalytics;

public class TestActivty extends Activity {

  @Override
  protected void onCreate(Bundle savedInstanceState)
  {
    super.onCreate();
    ……
    int result = GameAnalytics.initializeSdk(getApplicationContext(), “AppKey”, “CompanyID”, “AppVersion”, true);

    if(result != GameAnalytics.S_SUCCESS) {
        Log.d(TAG, "initialize error " + GameAnalytics.getResultMessage(result));
    }
    ……
    // Toast Push SDK 
    int error = PushSdk.register(APP_KEY, UID, new PushSdk.OnRegister() {
        @Override
        public void fire(int error) {
            if (error == 0) {
                // Call UID as element once the registration is complete 
                GameAnalytics.tracePushUserId(UID); 
            } 
        }
    }
……
```

### Campaign Listener implementation and registration

SDK brings information of Campaign and reward by communicating with Campaign on a regular basis. If there is a campaign to be proceeded to users or reward information, it is notified through CompaignListender.

Therefore, CampaignListener should be implemented to receive Campaign information.

```java
public interface CampaignListener {
    void onCampaignVisibilityChanged(String adspaceName, bool show);
    void onCampaignLoadSuccess(String adspaceName);
    void onCampaignLoadFail(String adspaceName, int errorCode, String errorMessage);
    void onMissionComplete(List<String> missionList);
    void onCampaignClick(String callbackInfo);
    void onPromotionVisibilityChanged(bool show);
}
```


Each Callback is called in the following cases.

* OnCampaignVisibilityChanged : it is called when relevant pop-ups or banners either appear or disappear by calling showCampaign and hideCampaign.   
* OnMissionComplete : it is called when a user progresses Campaign/Promotion and there is reward information as a user completes targeted missions. Using the provided information here, reward should be given through game server. As for process related to Campaign reward, refer to the “Campaign Application Guide” document..   
* OnCampaignLoadSuccess, OnCampaignLoadFail : it instructs Campaign information passing results. No special measures are required about this callback in the game. It is just a callback provided to check log.
* OnCampaignClick : If you select a link type to Deeplink. analyticsDidCampaignClick is a callback passing registered string. Refer to the received string, It handles any action in the game
* OnPromotionVisibilityChanged : in case of using Promotion, it is called when Promotion View is opened and closed.

Register implemented CampaignListener through setCampaignListener.

```java
public void setListener() {
  ……
  GameAnalytics.setCampaignListener(new MyCampaignListener() {
    public void onCampaignVisibilityChanged(string adspaceName, bool show) {
      ……
    }

    public void onCampaignLoadSuccess(string adspaceName) {
      // for Debugging
    }

    public void onCampaignLoadFail(string adspaceName, int errorCode, string errorMessage) {
      // for Debugging
    }

    public void onMissionComplete(List<string> missionList) {
      // in missionList String, key/value is provided as info fitment numerator‘|’.
      // with this value, reward is provided to users after verifying in the promotion server
      // through the game server.
    }
    
    void onCampaignClick(string callbackInfo) {
      // If you select a link type to Deeplink. analyticsDidCampaignClick is a callback passing registered string.
      // Refer to the received string, It handles any action in the game
    }
    
    public void onPromotionVisibilityChanged(bool show) {
      // When Promotion View is opened, show is passed to true.
      // When show is true, lowering game rendering performance is possible.
      // In contrast, when show is false, game rendering can be retrieved.
    }
  });
}
```

### CampaignShow/Hide
It is a method that shows pop-up/banner registered in Analytics website in case of a currently ongoing campaign to users and hides exposed pop-up/banner. For adspaceName, which is a parameter, adaspace name can be used that is defined at the time of registration of Campaign in Analytics website. Adspace means a particular location within the game where pop-up/banner is expressed.

As showCampaign() method does not operate if there is not a campaign that uses corresponding adspace, if functions are called as different adspaceNames in many other places of the game that are expected to expose pop-up/banner, game system administrator can easily promote pop-up/banner just by registering campaign in Anayltics website without changing any game client.

As for the method to register for Adspace, refer to "Campaign Test Guide.

```java
public static int showCampaign(String adspaceName, Activity activity)
public static int showCampaign(String adspaceName, Activity activity, int animation, int lifeTime) 
public static int hideCampaign(String adspaceName)
public static int hideCampaign(String adspaceName, int animation)
```

## Using custom event

It can be used to define particulars and analyze them in each game.

For example, in case of Fever Time Item, use it as described below. All the used codes are defined in the game and used. The example provided down below is a code defined to trace change patterns at a particular stage.

```java
GameAnalytics.traceEvent("ITEM", "ITEM_USE", "FEVER", "STAGE_10", 1, 10);
```

It can used to trace Boss Battle results at a particular level.

```java
GameAnalytics.traceEvent("STAGE", "STAGE_BOSS_VICTORY", "DRAGON_VALLEY", "BOSS_MOB", 1, 10);
```

In addition to this, it can be used to trace specialized events for a number of purposes.

String Type Parameter (event type, event code, param1, param2) utilized in traceEvent can be used up to 50byte each. And pram1 that can take place at a low rank of an event can be used up to 300, and param2 that can take place at a low rank of param1 can be used up to 200.

Event Code must be a unique value. Please be careful when setting the event code as the identical event code will lead to the summed up index even with different event type. 

For more details, refer to Toast Analytics website. (It can be downloaded by clicking on "Page Guide" on the upper part of the right side of Custom Event Page.)


## Promotion implementation

Use it when promotion in the game is implemented with a different game.

### Promotion implementation advance preparation
Promotion implementation and its execution are explained in a separate guide.

### Adding promotion button
When promotion information and button image is registered in Analytics setting page, download and save it into Device at the point of SDK initialization.

Using button image in the game, button should be created at an appropriate location.

Check and see if promotion can be executed before creating a button. If the system operator has made it so that promotion is not used, or button image has failed to be downloaded, or service is in maintenance or troubled for some reason, promotion cannot be proceeded, so the button should not be indicated on the screen in such cases. Promotion availability can be figured out through “isPromotionAvailable()”. If promotion is in an available state, created a button at an appropriate location by identifying the button image route through the function of “getPromotionButtonImagePath()”. (Save the button image in PNG format.) If useLoggingUserID is set as true in initializeSDK, user ID should be delivered through “setCampaignUserId(String)”.
(It is available to create a button by utilizing images included in game-distributed package rather than using the image registered in Analytics setting. But, promotion availability must be checked through isPromotionAvailable before creating the button at this time as well.)

```java
if (GameAnalytics.isPromotionAvailable() == true) {
    String buttonImagePath = GameAnalytics.getPromotionButtonImagePath();
    Drawable d = new BitmapDrawable(activity.getResources(), buttonImagePath);
    ……
} else {
    Debug.Log ("Hide Toast Promotion Button");
}
```

### Executing promotion
In case of touching the promotion button, execute promotion by calling “launchPromotionPage()”.

```java
private void touchPromotionButton() {
    ……
    GameAnalytics.launchPromotionPage();
    ……
}
```

Promotion contents are provided through the internal use of Web view in “launchPromotionPage()”. In order to use this function, Activity that corresponds to AndroidManifet.xml setting should be added.

Fixing the screen width/lengthwise is set through android:screenOrientation. (<http://developer.android.com/guide/topics/manifest/activity-element.html#screen>)

```xml
<activity
    android:configChanges="keyboard|keyboardHidden|orientation|
        screenLayout|uiMode|screenSize|smallestScreenSize"
    android:name="com.toast.android.analytics.PromotionActivity" />
```

Also, Install Receiver must be registered to measure effects of advertisements at the time of installation/execution of an app.

Install Receiver is needed to measure effects in case that an app is installed through promotion (only in case of Google Play). Execution Receiver is needed to measure execution effects through promotion in case that an app is installed. Refer to “2.2.2. AndroidManifest setting”.

### Reward
Reward is provided when promotion page exposed to users. Moreover, when an app is installed through promotion or targeted missions are accomplished, reward is provided as well.

Information about reward is delivered through “onMissionComplete” of “CampaignListener”

Refer to "Promotion Application and Operation guide" for the process of reward.


## Measuring duration

It can measure time taken in a particular interval. For example, it can be utilized in some discretionary areas in case of measuring time taken for tutorial, Scene switching, etc.

For Intro Scene loading time, it is used as below. "INTRO_LOADING” is a value defined for particular intervals in the game.

```java
private void onStart() {
    GameAnalytics.traceStartSpeed("INTRO_LOADING");
}

private void onLoadCompleted() {
    GameAnalytics.traceEndSpeed("INTRO_LOADING");
}
```

## Track Facebook installation

You may track app installation from Facebook ad. This feature uses the Deep Linking feature offered by Facebook.
Please refer to the Facebook guidelines (https://developers.facebook.com/docs/app-ads/deep-linking) for more information on tracking and testing. ApplinkData.fetchDeferredAppLinkData is an API provided by Facebook SDK. 
(https://developers.facebook.com/docs/reference/android/current/class/AppLinkData/)

```java 
AppLinkData.fetchDeferredAppLinkData(this,
    new AppLinkData.CompletionHandler() {
        @Override
            public void onDeferredAppLinkDataFetched(AppLinkData appLinkData) {
                if (appLinkData != null) {
                    GameAnalytics.traceFacebookInstall(context, String.valueOf(appLinkData.getTargetUri()));
                }
            }
        }
);}
```

# SDK Setting

## Activating debug mode
It can set log output availability for SDK log verification during development.

This function is available both before/after initializeSDK. The defualt value is setDebugMode(false).

Start Log tags as “Analytics:”. (By designating log cat filter as "Analytics" in Eclipse, logs generated in SDK can be identified.)

```java
private void Start () {
     ……
     GameAnalytics.setDebugMode(true);
     ……

     int result = GameAnalytics.initializeSdk ("APPKEY", "COMPANYID", "VERSION", false);

     if (result != 0) {
        // SDK Initialization failure
     }
     ……
}
```

In case that debug mode is activated, contents of log delivery can be identified. Whether or not logs are properly delivered can be identified by seeing logs reacted in response after sending logs. If there is log string such as described below, collected data must have been properly delivered to the server. (*** is an altering value depending on circumstances.)

```
Android : server response (***) : 200 OK
```


## Identifying device information
It can identify Device information collected in SDK.

Currently traceable values are Device ID, Push User ID, and Campaign User ID. These values are needed to test campaign implementation. For more details, refer to "Campaign implementation guide".

They are Key values used to identify Device information.
- public static final String DEVICE_INFO_DEVICEID = “deviceId”;
- public static final String DEVICE_INFO_CAMPAIGN_USERID = ”campaignUserId”;
- public static final String DEVICE_INFO_PUSH_USERID = "pushUserId";

```java
private void printDeviceInfo() {
     String deviceID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_DEVICEID);
     String pushUserID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_CAMPAIGN_USERID);
     String campaignUserID = GameAnalytics.getDeviceInfo(GameAnalytics.DEVICE_INFO_PUSH_USERID);
     ……
}
```

## SDK version identification
SDK version can be identified through the "GameAnalytics.getVersion()” function.

```java
public static String getVersion()
```

